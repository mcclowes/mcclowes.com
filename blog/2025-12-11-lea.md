---
title: "Lea: A Programming Language That Reads Like You Think"
authors: mcclowes
tags: [projects, dev, programming languages]
---

I built a programming language. It's called [Lea](https://github.com/mcclowes/lea), and it's designed around one core belief: code should flow the way your brain does—left to right, step by step.

<!--truncate-->

## Why Another Language?

Most programming languages force you to read inside-out. Consider filtering and transforming a list in JavaScript:

```javascript
console.log(reduce(map(filter(numbers, x => x > 2), x => x * x), 0, (a, b) => a + b))
```

Your eyes jump to the innermost function, then work outward. It's backwards from how we naturally describe the process: "take the numbers, filter them, square them, sum them up."

Lea fixes this with pipes:

```lea
let numbers = [1, 2, 3, 4, 5]

numbers
  /> filter((x) -> x > 2)
  /> map((x) -> x * x)
  /> reduce(0, (acc, x) -> acc + x)
  /> print  -- 50
```

Data flows left-to-right through transformations. You read it exactly as you'd explain it.

## Resilience as Syntax

The other thing that always frustrated me: handling retries, timeouts, and caching in production code requires so much boilerplate. In Lea, these are first-class language features through decorators:

```lea
let fetchUser = (id) -> http.get("/users/" ++ id)
  #retry(3)
  #timeout(1000)
  #memo
```

No wrapper functions. No importing retry libraries. The resilience behaviour is declared right where the function is defined.

## Built-in Dependency Injection

Testing code that depends on external services usually means reaching for mocking libraries. Lea has a native Context system that makes dependency injection trivial:

```lea
context Logger = ConsoleLogger

let process = (data) -> {
  Logger.info("Processing...")
  data /> transform /> validate
}

-- In tests, just swap the context
provide TestLogger as Logger {
  process(testData)
}
```

No Jest mocks. No dependency injection frameworks. It's built into the language.

## The Philosophy

Lea occupies a specific niche: functional scripting with built-in resilience. It's designed for the kind of code that glues systems together—data pipelines, API orchestration, backend automation.

The goal isn't to replace JavaScript or Python everywhere. It's to make certain kinds of code dramatically more readable and robust.

Some design choices:

- **Immutability by default** - `let` for constants, `maybe` for the rare mutable variable
- **Optional typing** - Start dynamic, add types gradually with `:: Int` annotations
- **Pipeline-first** - The `/>` operator isn't an afterthought; it's the primary way to compose operations

## Current State

Lea is still experimental. It has a tree-walk interpreter written in TypeScript, a VS Code extension for syntax highlighting, and a REPL for playing around. It's perfect for learning about language design or prototyping data transformation logic.

Is it production-ready? No. But that's not really the point. Sometimes you build things to explore ideas, to see what programming could feel like if we made different choices.

If you're curious, check out the [GitHub repo](https://github.com/mcclowes/lea). Run the REPL. Try writing some pipelines. Let me know what you think.

```bash
git clone https://github.com/mcclowes/lea.git
cd lea
npm install
npm run repl
```
